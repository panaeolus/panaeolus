var emacs = typeof ace !== 'undefined' ? ace.acequire("ace/keyboard/emacs") : null;

const prepareForSourceTransform = function(ed, args) {
    // helper to gather the typically needed data
    var selRange = ed.getSelectionRange(),
        posIdx = ed.session.doc.positionToIndex(ed.getCursorPosition()),
        ast = ed.session.$ast;
    ast && ed.pushEmacsMark && ed.pushEmacsMark(ed.getCursorPosition());
    return {
        pos: posIdx,
        selStart: ed.session.doc.positionToIndex(selRange.start),
        selEnd: ed.session.doc.positionToIndex(selRange.end),
        isSelecting: !!ed.session.$emacsMark || (args && !!args.shifted),
        ast: ast,
        source: ed.getValue(),
        parentSexps: ast && paredit.walk.containingSexpsAt(ast, posIdx, paredit.walk.hasChildren)
    }
};

const indentFn = function(ed, args) {
    // paredit.ace.indent(ed);
    args = args || {};
    var data = prepareForSourceTransform(ed,args);
    if (!data.ast) return;
    var from = args.from, to = args.to;
    if (typeof from !== 'number')
        from = ed.session.doc.positionToIndex(ed.getSelectionRange().start);
    if (typeof to !== 'number')
        to = ed.session.doc.positionToIndex(ed.getSelectionRange().end);
    let indent2 = paredit.editor.indentRange(data.ast, ed.getValue(), from, to);
    applyPareditChanges(ed, indent2.changes,
                        indent2.changes.newIndex, false);
};

const newlineAndIndent = function(ed, args) {
    var data = prepareForSourceTransform(ed);
    if (!data.ast) return;
    var src = data.source.slice(0,data.pos) + "\n" + data.source.slice(data.pos),
        newPos = {row: ed.getCursorPosition().row+1,column:0},
        ast = paredit.parse(src, {addSourceForLeafs: true}),
        indent = paredit.editor.indentRange(ast, src, data.pos+1, data.pos+1);
    applyPareditChanges(ed,
                        [['insert', data.pos, "\n"]].concat(indent.changes), indent.newIndex)
}

function undoStackSize(ed) {
    return ed.session.getUndoManager().$undoStack.length;
}

const applyPareditChanges = function(ed, changes, newIndex, indent) {
    if(!emacs) {
        emacs = typeof ace !== 'undefined' ? ace.acequire("ace/keyboard/emacs") : null;
    }
    // ed: ace editor instance
    // changes:  alist of insert/remove instructions generated by
    //           paredit.editor
    // newIndex: where to put the cursor after applying the changes
    if (!changes || !changes.length) return;
    var nUndos = undoStackSize(ed);
    changes.forEach(function(ea) {
        var type = ea[0];
        if (type === 'insert') {
            ed.session.insert(
                ed.session.doc.indexToPosition(ea[1]), ea[2]);
        } else if (type === 'remove') {
            var range = {
                start: ed.session.doc.indexToPosition(ea[1]),
                end: ed.session.doc.indexToPosition(ea[1]+ea[2])
            }
            var killRingString = ed.session.getTextRange(range);
            if (killRingString.length > 1 && emacs) emacs.killRing.add(killRingString);
            ed.session.remove(range);
        }
    });

    if (newIndex)
        ed.selection.moveToPosition(
            ed.session.doc.indexToPosition(newIndex));

    if (!indent) ed.session.markUndoGroup();
    else {
        var ast = ed.session.$ast = paredit.parse(ed.getValue(), {addSourceForLeafs: true});
        if (!ast || (ast.errors && ast.errors.length)) return;
        var indentStart = typeof indent === "object" ?
                          indent.start : changes[0][1],
            indentEnd = typeof indent === "object" ?
                        indent.end : changes[changes.length-1][1];
        indentFn(ed, {from: indentStart, to: indentEnd})
        if (undoStackSize(ed) - nUndos >= 2)
            mergeLast2Undos(ed);
    }

}

const clojureSexpMovement = function(ed, method, args) {
    var data = prepareForSourceTransform(ed,args);
    if (!data.ast || !data.ast.type === 'toplevel') return;
    var moveToIdx = paredit.navigator[method](data.ast, data.pos);
    if (moveToIdx === undefined) return false;
    var moveToPos = ed.session.doc.indexToPosition(moveToIdx),
        method = (data.isSelecting ? 'select' : 'moveCursor') + 'ToPosition';
    ed.selection[method](moveToPos);
    ed.renderer.scrollCursorIntoView();
    return true;
};

module.exports = {
    applyPareditChanges: applyPareditChanges,
    clojureSexpMovement: clojureSexpMovement,
    newlineAndIndent: newlineAndIndent,
    pareditIndent: indentFn,
};
